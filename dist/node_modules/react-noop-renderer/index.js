(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react'), require('scheduler')) :
	typeof define === 'function' && define.amd ? define(['react', 'scheduler'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.ReactNoopRenderer = factory(global.React, global.Scheduler));
})(this, (function (React, Scheduler) { 'use strict';

	function _interopNamespaceDefault(e) {
		var n = Object.create(null);
		if (e) {
			Object.keys(e).forEach(function (k) {
				if (k !== 'default') {
					var d = Object.getOwnPropertyDescriptor(e, k);
					Object.defineProperty(n, k, d.get ? d : {
						enumerable: true,
						get: function () { return e[k]; }
					});
				}
			});
		}
		n.default = e;
		return Object.freeze(n);
	}

	var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);
	var Scheduler__namespace = /*#__PURE__*/_interopNamespaceDefault(Scheduler);

	const FunctionComponent = 0;
	const HostRoot = 3;
	const HostComponent = 5;
	const HostText = 6;
	const Fragment = 7;

	const NoFlags = 0b0000000;
	const Placement = 0b0000001;
	const Update = 0b0000010;
	const ChildDeletion = 0b0000100;
	// 当前fiber更新需要触发useEffect
	const PassiveEffect = 0b0001000;
	const MutationMask = Placement | Update | ChildDeletion;
	const PassiveMask = PassiveEffect | ChildDeletion;

	const SyncLane = 0b0001;
	const NoLane = 0b0000;
	const NoLanes = 0b0000;
	/**
	 * @description 将两个独立的优先级（Lane）合并成一个表示多个优先级的集合（Lanes）
	 * @param laneA
	 * @param laneB
	 * @returns
	 */
	function mergeLanes(laneA, laneB) {
	    return laneA | laneB;
	}
	/**
	 * @description 根据上下文返回优先级
	 * @returns
	 */
	function requestUpdateLane() {
	    return SyncLane;
	}
	/**
	 * @description 获取优先级最高的lane（越小优先级越高）
	 * @param lanes
	 * @returns
	 */
	function getHighestPriorityLane(lanes) {
	    return lanes & -lanes;
	}
	function markRootFinished(root, lane) {
	    root.pendingLanes &= ~lane;
	}

	class FiberNode {
	    type;
	    tag;
	    pendingProps;
	    key;
	    stateNode;
	    ref;
	    return;
	    sibling;
	    child;
	    index;
	    memoizedProps;
	    memoizedState;
	    alternate;
	    flags;
	    subtreeFlags;
	    updateQueue;
	    // 这个属性是一个数组，它持有那些需要从 DOM 中移除的子 FiberNode 的引用。
	    deletions;
	    constructor(tag, pendingProps, key) {
	        // 实例
	        this.tag = tag;
	        this.key = key || null;
	        // 对于类组件 (Class Component) Fiber 节点, stateNode 指向的是该类组件的实例
	        // 对于宿主组件 (Host Component) Fiber 节点, stateNode 指向的是该 Fiber 节点对应的真实 DOM 元素
	        // 对于函数组件 (Function Component) Fiber 节点, 在现代 React (特别是引入 Hooks 之后)，函数组件本身没有实例。因此，对于函数组件的 Fiber 节点，stateNode 通常是 null。函数组件的状态和副作用是通过 Hooks 来管理的，这些信息存储在 Fiber 节点的其他属性上（如 memoizedState，用于存储 Hooks 的链表）。
	        // 对于宿主根节点 (Host Root) Fiber 节点, stateNode 指向的是 FiberRoot 对象
	        // 对于宿主文本节点 (Host Text) Fiber 节点, stateNode 指向的是该文本对应的真实 DOM 文本节点 (Text Node)
	        this.stateNode = null;
	        // 对于类组件 (Class Component) Fiber 节点：
	        // type 指向的是该类组件的构造函数 (constructor) 本身。例如，如果你定义了一个组件 class MyComponent extends React.Component {...}，那么代表 <MyComponent /> 的 Fiber 节点的 type 就是 MyComponent 这个类。
	        // 对于函数组件 (Function Component) Fiber 节点：
	        // type 指向的是该函数组件本身。例如，如果你定义了一个组件 function MyFunctionComponent() {...} 或者 const MyFunctionComponent = () => {...}，那么代表 <MyFunctionComponent /> 的 Fiber 节点的 type 就是 MyFunctionComponent 这个函数。
	        // 对于宿主组件 (Host Component) Fiber 节点 (例如 <div>, <span>, <p> 等原生 DOM 元素)：
	        // type 是一个字符串，表示该 DOM 元素的标签名。例如，对于一个 <div> 元素，其 Fiber 节点的 type 就是字符串 "div"。
	        // 对于原生 React 元素，如 Fragment、Profiler、StrictMode、Suspense、ContextProvider、ContextConsumer 等：
	        // type 通常是 React 内部定义的特殊 Symbol 值或者对象，用来标识这些特定的 React 结构。例如，Fragment 的 type 是 REACT_FRAGMENT_TYPE 这个 Symbol。
	        // 对于宿主文本节点 (Host Text) Fiber 节点：
	        // 文本节点没有 type 属性，因为它们的内容直接存储在 pendingProps (或 memoizedProps) 中。通常，React 会根据父组件的 children 来创建文本节点。
	        this.type = null;
	        // 构成树状结构
	        this.return = null;
	        this.sibling = null;
	        this.child = null;
	        this.index = 0;
	        this.ref = null;
	        // 作为工作单元
	        this.pendingProps = pendingProps; // pendingProps 指的是组件从 React 元素（即 JSX 中定义的）接收到的，即将要应用的 props
	        this.memoizedProps = null; // memoizedProps 指的是在上一次渲染（render）过程中，组件最终实际使用的 props
	        this.memoizedState = null;
	        // 对于 HostRoot Fiber:
	        // 是 UpdateQueue<ReactElementType | null> 类型的实例，
	        // 这个队列的 shared.pending 属性会持有一个循环链表，
	        // 链表中的每个节点是一个 Update 对象，
	        // 每个 Update 对象的 payload 就是要渲染到根节点的 React 元素（例如 <App />）或者 null（用于卸载）。
	        // 对于 FunctionComponent Fiber:
	        // 用来存储一个 FCUpdateQueue 对象
	        this.updateQueue = null;
	        this.alternate = null;
	        // 副作用
	        this.flags = NoFlags;
	        this.subtreeFlags = NoFlags;
	        this.deletions = null;
	    }
	}
	// FiberRootNode 是 React 应用中所有 Fiber 节点的根，它代表了整个应用的实例
	class FiberRootNode {
	    // container 指的是承载整个 React 应用的实际 DOM 元素。
	    container;
	    current;
	    finishedWork;
	    pendingLanes;
	    finishedLane; // 本次更新，消费的lane
	    pendingPassiveEffects;
	    constructor(container, hostRootFiber) {
	        this.container = container;
	        this.current = hostRootFiber;
	        hostRootFiber.stateNode = this;
	        this.finishedWork = null;
	        this.pendingLanes = NoLanes;
	        this.finishedLane = NoLane;
	        // 收集回调的容器
	        this.pendingPassiveEffects = {
	            unmount: [],
	            update: []
	        };
	    }
	}
	/**
	 *
	 * @description 负责创建或复用一个与 current Fiber 节点相对应的 wip Fiber 节点
	 * @param current current node，来自当前已渲染树的 FiberNode
	 * @param pendingProps 新 props
	 * @returns {FiberNode}
	 * * 类型：wip fibernode
	 * * 结构：
	 * 	* 实例(tag, key, stateNode, type)：赋值，数据来自 current
	 * 	* 树状结构（return, sibling, child, index）：null
	 * 	* 工作单元(pendingProps, memoizedProps, memoizedState, updateQueue, alternate)：赋值，数据来自 current & pendingProps
	 * 	* 副作用(flags, subtreeFlags, deletions)：重置
	 */
	const createWorkInProgress = (current, pendingProps) => {
	    // 1. 尝试获取 alternate (如果存在的话，它是上一个渲染周期中的 wip 节点)
	    let wip = current.alternate;
	    // 2. 处理 "mount" 情况 (这个 Fiber 首次在 wip 树中被处理，或者没有 alternate 存在)
	    if (wip === null) {
	        // mount
	        wip = new FiberNode(current.tag, pendingProps, current.key);
	        wip.stateNode = current.stateNode;
	        wip.alternate = current;
	        current.alternate = wip;
	        // 3. 处理 "update" 情况 (一个 alternate/wip 节点已经存在，所以我们复用它)
	    }
	    else {
	        // update
	        wip.pendingProps = pendingProps;
	        wip.flags = NoFlags;
	        wip.subtreeFlags = NoFlags;
	        wip.deletions = null;
	    }
	    // 4. mount 和 update 情况下都会复制/设置的通用属性：
	    wip.type = current.type;
	    wip.updateQueue = current.updateQueue;
	    wip.child = current.child;
	    wip.memoizedProps = current.memoizedProps;
	    wip.memoizedState = current.memoizedState;
	    // 5. 返回 work-in-progress FiberNode
	    return wip;
	};
	/**
	 * @description 根据一个 React Element 创建一个新的 FiberNode 实例。
	 * @param element
	 * @returns
	 */
	function createFiberFromElement(element) {
	    const { type, key, props } = element;
	    let fiberTag = FunctionComponent;
	    if (typeof type === 'string') {
	        // <div/> type: 'div'
	        fiberTag = HostComponent;
	    }
	    else if (typeof type !== 'function' && true) {
	        console.warn('为定义的type类型', element);
	    }
	    const fiber = new FiberNode(fiberTag, props, key);
	    fiber.type = type;
	    return fiber;
	}
	function createFiberFromFragment(elements, key) {
	    const fiber = new FiberNode(Fragment, elements, key);
	    return fiber;
	}

	/**
	 * @description 一个创建 Update 对象的工厂函数
	 */
	const createUpdate = (action, lane) => {
	    return {
	        action,
	        lane,
	        next: null
	    };
	};
	/**
	 * @description 一个创建 UpdateQueue 对象的工厂函数
	 */
	const createUpdateQueue = () => {
	    return {
	        shared: {
	            pending: null
	        },
	        // 这个 dispatch 属性稍后（比如在 useState Hook 初始化时）
	        // 会被设置为与这个队列相关联的实际的派发函数（也就是我们常说的 setState 函数）
	        dispatch: null
	    };
	};
	/**
	 * @description 这个函数用于将一个 Update 对象“入队”到一个 UpdateQueue 中
	 */
	const enqueueUpdate = (updateQueue, update) => {
	    // `pending` 指向的是当前队列中最后一个更新。
	    const pending = updateQueue.shared.pending;
	    // 构建单向循环链表
	    if (pending === null) {
	        // pending = a -> a
	        update.next = update;
	    }
	    else {
	        // pending = b -> a -> b
	        // pending = c -> a -> b -> c
	        update.next = pending.next;
	        pending.next = update;
	    }
	    updateQueue.shared.pending = update;
	};
	/**
	 * @description 计算并返回新的状态
	 * @param baseState 进行更新计算前的基础状态（当前状态）
	 * @param pendingUpdate 等待处理的更新对象，如果队列为空，则为 null
	 * @param renderLane
	 * @returns 函数返回一个对象，这个对象有一个 memoizedState 属性，代表应用更新后得到的新状态
	 */
	const processUpdateQueue = (baseState, pendingUpdate, renderLane) => {
	    const result = {
	        memoizedState: baseState
	    };
	    if (pendingUpdate !== null) {
	        // 第一个update
	        const first = pendingUpdate.next;
	        let pending = pendingUpdate.next;
	        do {
	            const updateLane = pending.lane;
	            if (updateLane === renderLane) {
	                const action = pending.action;
	                if (action instanceof Function) {
	                    // baseState 1 update (x) => 4x -> memoizedState 4
	                    baseState = action(baseState);
	                }
	                else {
	                    // baseState 1 update 2 -> memoizedState 2
	                    baseState = action;
	                }
	            }
	            else {
	                {
	                    console.error('不应该进入updateLane !== renderLane逻辑');
	                }
	            }
	            pending = pending.next;
	        } while (pending !== first);
	    }
	    result.memoizedState = baseState;
	    return result;
	};

	const supportSymbol = typeof Symbol === 'function' && Symbol.for;
	const REACT_ELEMENT_TYPE = supportSymbol
	    ? Symbol.for('react.element')
	    : 0xeac7;
	const REACT_FRAGMENT_TYPE = supportSymbol
	    ? Symbol.for('react.fragment')
	    : 0xeacb;

	/**
	 * 负责处理一个父 Fiber 节点的子节点的协调（reconciliation）工作
	 */
	/**
	 * @description 这是一个工厂函数。它本身不直接进行协调工作，而是返回一个执行协调工作的函数。
	 * @param {boolean} shouldTrackEffects
	 * * 如果为 true，协调器会追踪“副作用”，比如需要在 DOM 中放置一个新元素（Placement）或删除一个旧元素（ChildDeletion）。这通常在更新一个已存在的组件树时使用。
	 * * 如果为 false，它不会以同样的方式追踪这些副作用。这通常在组件树首次挂载时使用，因为所有东西都是新的，都需要被放置。
	 */
	function ChildReconciler(shouldTrackEffects) {
	    /**
	     * @description 将一个 fiber 子节点标记为删除
	     * @param returnFiber - 使用 reconcileChildFibers 作用域的 returnFiber， wip的父节点
	     * @param childToDelete  - 使用 reconcileChildFibers 作用域的 currentFiber， current tree对应的的子节点
	     * @see {@link reconcileChildFibers}
	     * @returns
	     */
	    function deleteChild(returnFiber, childToDelete) {
	        // 如果不在追踪副作用，就没必要追踪删除，例如在初始挂载时，没有旧东西可删
	        if (!shouldTrackEffects) {
	            return;
	        }
	        const deletions = returnFiber.deletions;
	        if (deletions === null) {
	            returnFiber.deletions = [childToDelete];
	            returnFiber.flags |= ChildDeletion;
	        }
	        else {
	            deletions.push(childToDelete);
	        }
	    }
	    /**
	     * @description 在组件更新时，遍历并标记从某个旧的子 Fiber 节点开始的所有后续兄弟节点，以便在提交阶段将它们从 DOM 中移除
	     * @param returnFiber work-in-progress 树中的父节点
	     * @param currentFirstChild current tree 中，需要开始删除的第一个子 Fiber 节点
	     */
	    function deleteRemainingChildren(returnFiber, currentFirstChild) {
	        // 在挂载阶段没有旧节点需要删除，所以如果 `shouldTrackEffects` 为 `false`，函数直接返回，不做任何操作
	        if (!shouldTrackEffects) {
	            return;
	        }
	        // 游标
	        let childToDelete = currentFirstChild;
	        while (childToDelete !== null) {
	            deleteChild(returnFiber, childToDelete);
	            childToDelete = childToDelete.sibling;
	        }
	    }
	    /**
	     * @description newChild 是单个 React 元素的情况
	     * @param returnFiber wip的父节点
	     * @param currentFiber 父节点在上一次渲染时的第一个子 Fiber 节点，代表旧的子节点或旧子节点链表的头部
	     * @param element 本次渲染中，父节点的新的、单一的子 React 元素
	     * @returns
	     */
	    function reconcileSingleElement(returnFiber, currentFiber, element) {
	        const key = element.key;
	        // 遍历旧的子 Fiber 节点链表，寻找一个可被复用的 currentFiber
	        while (currentFiber !== null) {
	            // 如果 currentFiber 存在，说明是更新操作，我们尝试复用。
	            if (currentFiber.key === key) {
	                // key相同
	                if (element.$$typeof === REACT_ELEMENT_TYPE) {
	                    if (currentFiber.type === element.type) {
	                        let props = element.props;
	                        // fragment 的 props 与其他不同
	                        if (element.type === REACT_FRAGMENT_TYPE) {
	                            props = element.props.children;
	                        }
	                        // type相同
	                        const existing = useFiber(currentFiber, props);
	                        existing.return = returnFiber;
	                        // 当前节点可复用，标记剩下的节点删除
	                        deleteRemainingChildren(returnFiber, currentFiber.sibling);
	                        return existing;
	                    }
	                    // key相同，type不同 删掉所有旧的（含 currentFiber ）
	                    deleteRemainingChildren(returnFiber, currentFiber);
	                    break;
	                }
	                else {
	                    {
	                        console.warn('还未实现的react类型', element);
	                        break;
	                    }
	                }
	            }
	            else {
	                // key不同，删掉旧的，移动到下一个旧的兄弟节点，继续尝试匹配
	                deleteChild(returnFiber, currentFiber);
	                currentFiber = currentFiber.sibling;
	            }
	        } // while 循环结束
	        // 如果代码执行到这里，意味着：
	        //    a. 初始的 currentFiber 就是 null (即父节点之前没有子节点，这是首次挂载这个子元素)。
	        //    b. 或者，遍历了所有旧的子 Fiber 节点，但没有找到 key 和 type 都匹配的可复用节点。
	        //    c. 或者，找到了相同的 key 但 type 不同，导致 break 了循环。
	        //    在这些情况下，都需要为新的 element 创建一个全新的 Fiber 节点。
	        // 根据element创建fiber
	        let fiber;
	        // fragment
	        if (element.type === REACT_FRAGMENT_TYPE) {
	            fiber = createFiberFromFragment(element.props.children, key);
	        }
	        else {
	            fiber = createFiberFromElement(element);
	        }
	        fiber.return = returnFiber;
	        return fiber;
	    }
	    /**
	     * @description 专门用于处理文本内容（例如 <div>你好</div> 中的 "你好"）。
	     * @param returnFiber 使用 reconcileChildFibers 作用域的 returnFiber， wip的父节点
	     * @param currentFiber 使用 reconcileChildFibers 作用域的 currentFiber， current tree对应的的子节点
	     * @param content 文本内容
	     * @returns 新创建的或者被复用的 wip，这个 FiberNode 代表了传入的文本内容
	     */
	    function reconcileSingleTextNode(returnFiber, currentFiber, content) {
	        // 1. 检查是否存在上一次渲染的 Fiber 节点 (currentFiber)
	        while (currentFiber !== null) {
	            // 如果存在，说明是更新操作
	            // 2. 检查上一次的 Fiber 节点是否也是一个文本节点
	            if (currentFiber.tag === HostText) {
	                // 类型没变，可以复用
	                const existing = useFiber(currentFiber, { content });
	                existing.return = returnFiber;
	                // 1 2 3 -> 1, 需要删除 2, 3
	                deleteRemainingChildren(returnFiber, currentFiber.sibling);
	                return existing;
	            }
	            // 如果 currentFiber 存在，但它的类型不是 HostText
	            deleteChild(returnFiber, currentFiber);
	            currentFiber = currentFiber.sibling;
	        }
	        // 3. 没有对应的 Fiber 节点，创建新的文本 Fiber 节点
	        const fiber = new FiberNode(HostText, { content }, null);
	        fiber.return = returnFiber;
	        return fiber;
	    }
	    /**
	     * @description 是否是新创建的节点（且在更新阶段）来打上 Placement 标记。
	     * @param fiber wip-fiber-node
	     * @returns （可能会）打上 Placement flag 的原 fiber 节点
	     */
	    function placeSingleChild(fiber) {
	        if (shouldTrackEffects && fiber.alternate === null) {
	            fiber.flags |= Placement;
	        }
	        return fiber;
	    }
	    /**
	     * @description 对比新的子节点数组 (newChild) 和上一次渲染时的旧子节点链表 (currentFirstChild 开始的链表)，然后生成一个新的 work-in-progress (wip) 子 Fiber 节点链表
	     * @param returnFiber
	     * @param currentFirstChild
	     * @param newChild 存放 ReactElement 的数组
	     * @returns
	     */
	    function reconcileChildrenArray(returnFiber, currentFirstChild, newChild) {
	        // 最后一个可复用fiber在current中的index
	        let lastPlacedIndex = 0;
	        // 创建的最后一个fiber
	        let lastNewFiber = null;
	        // 创建的第一个fiber
	        let firstNewFiber = null;
	        // 1.将current保存在map中
	        const existingChildren = new Map();
	        let current = currentFirstChild;
	        while (current !== null) {
	            const keyToUse = current.key !== null ? current.key : current.index;
	            existingChildren.set(keyToUse, current);
	            current = current.sibling;
	        }
	        for (let i = 0; i < newChild.length; i++) {
	            // 2.遍历newChild，寻找是否可复用
	            const after = newChild[i];
	            const newFiber = updateFromMap(returnFiber, existingChildren, i, after);
	            if (newFiber === null) {
	                continue;
	            }
	            // 3. 标记移动还是插入
	            newFiber.index = i;
	            newFiber.return = returnFiber;
	            if (lastNewFiber === null) {
	                lastNewFiber = newFiber;
	                firstNewFiber = newFiber;
	            }
	            else {
	                lastNewFiber.sibling = newFiber;
	                lastNewFiber = lastNewFiber.sibling;
	            }
	            if (!shouldTrackEffects) {
	                continue;
	            }
	            const current = newFiber.alternate;
	            if (current !== null) {
	                const oldIndex = current.index;
	                if (oldIndex < lastPlacedIndex) {
	                    // 移动
	                    newFiber.flags |= Placement;
	                    continue;
	                }
	                else {
	                    // 不移动
	                    lastPlacedIndex = oldIndex;
	                }
	            }
	            else {
	                // mount
	                newFiber.flags |= Placement;
	            }
	        }
	        // 4. 将Map中剩下的标记为删除
	        existingChildren.forEach((fiber) => {
	            deleteChild(returnFiber, fiber);
	        });
	        return firstNewFiber;
	    }
	    /**
	     * @description 尝试从旧节点中找出可复用的，基于此创建 wip 节点
	     * @param returnFiber 父节点
	     * @param existingChildren Map，存储旧节点，[key, fiberNode]
	     * @param index 当前新子元素在 newChild 数组的索引
	     * @param element 新子元素
	     * @returns
	     */
	    function updateFromMap(returnFiber, existingChildren, index, element) {
	        const keyToUse = element.key !== null ? element.key : index;
	        const before = existingChildren.get(keyToUse);
	        // HostText
	        if (typeof element === 'string' || typeof element === 'number') {
	            if (before) {
	                if (before.tag === HostText) {
	                    existingChildren.delete(keyToUse);
	                    return useFiber(before, { content: element + '' });
	                }
	            }
	            return new FiberNode(HostText, { content: element + '' }, null);
	        }
	        // ReactElement
	        if (typeof element === 'object' && element !== null) {
	            switch (element.$$typeof) {
	                case REACT_ELEMENT_TYPE:
	                    // fragment 情况2: Fragment与其他组件同级
	                    if (element.type === REACT_FRAGMENT_TYPE) {
	                        return updateFragment$1(returnFiber, before, element, keyToUse, existingChildren);
	                    }
	                    if (before) {
	                        if (before.type === element.type) {
	                            existingChildren.delete(keyToUse);
	                            return useFiber(before, element.props);
	                        }
	                    }
	                    return createFiberFromElement(element);
	            }
	            // TODO 数组类型
	            if (Array.isArray(element) && true) {
	                console.warn('还未实现数组类型的child');
	            }
	        }
	        if (Array.isArray(element)) {
	            return updateFragment$1(returnFiber, before, element, keyToUse, existingChildren);
	        }
	        return null;
	    }
	    /**
	     * @param returnFiber 父节点 的 fiber node
	     * @param currentFiber 子节点 的 current fiber node
	     * @param newChild 子节点 的 ReactElement
	     */
	    return function reconcileChildFibers(returnFiber, currentFiber, newChild) {
	        // Fragment 情况1: Fragment 包裹其他组件
	        // 例子：<> <ChildA /><ChildB /> </>
	        const isUnkeyedTopLevelFragment = typeof newChild === 'object' &&
	            newChild !== null &&
	            newChild.type === REACT_FRAGMENT_TYPE &&
	            newChild.key === null;
	        if (isUnkeyedTopLevelFragment) {
	            newChild = newChild.props.children; // [<ChildA />, <ChildB />]
	        }
	        // 判断当前fiber的类型
	        if (typeof newChild === 'object' && newChild !== null) {
	            // 多节点的情况 ul> li*3
	            if (Array.isArray(newChild)) {
	                return reconcileChildrenArray(returnFiber, currentFiber, newChild);
	            }
	            switch (newChild.$$typeof) {
	                case REACT_ELEMENT_TYPE:
	                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFiber, newChild));
	                default:
	                    {
	                        console.warn('未实现的reconcile类型', newChild);
	                    }
	                    break;
	            }
	        }
	        // HostText
	        if (typeof newChild === 'string' || typeof newChild === 'number') {
	            return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFiber, newChild));
	        }
	        if (currentFiber !== null) {
	            // 兜底删除
	            deleteRemainingChildren(returnFiber, currentFiber);
	        }
	        {
	            console.warn('未实现的reconcile类型', newChild);
	        }
	        return null;
	    };
	}
	/**
	 * @description -
	 * * 作用：基于这个 旧节点 和 新的 props 创建一个对应的 wip fiber node 的副本
	 * * 流程：1. 通过 `createWorkInProgress()` 制作出新节点 2. 添加树状结构
	 * @param fiber
	 * @param pendingProps
	 * @returns
	 * * 副本的结构
	 * 	* 实例: 赋值, 来自于传入的 fiber
	 * 	* 树形结构: 赋值,index = 0, sibling = null
	 * 	* 工作单元: 赋值，数据来自 `fiber & pendingProps`
	 * 	* 副作用: 重置
	 */
	function useFiber(fiber, pendingProps) {
	    const clone = createWorkInProgress(fiber, pendingProps);
	    clone.index = 0;
	    clone.sibling = null;
	    return clone;
	}
	/**
	 * @description 当在协调子节点数组（通过 reconcileChildrenArray -> updateFromMap）时遇到一个 Fragment 类型的 React 元素时，它会判断是否可以复用旧的 Fragment Fiber 节点。如果可以，就复用并更新；如果不可以，就创建一个新的 Fragment Fiber 节点。最终返回这个代表 Fragment 的 Fiber 节点。
	 * @param returnFiber
	 * @param current
	 * @param elements
	 * @param key
	 * @param existingChildren
	 * @returns
	 */
	function updateFragment$1(returnFiber, current, elements, key, existingChildren) {
	    let fiber;
	    // 判断是否可以复用旧的 Fragment Fiber 节点
	    if (!current || current.tag !== Fragment) {
	        // 不能复用
	        fiber = createFiberFromFragment(elements, key);
	    }
	    else {
	        // 可以复用
	        existingChildren.delete(key);
	        fiber = useFiber(current, elements);
	    }
	    fiber.return = returnFiber;
	    return fiber;
	}
	const reconcileChildFibers = ChildReconciler(true);
	const mountChildFibers = ChildReconciler(false);

	const internals = React__namespace.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

	// useEffect
	const Passive = 0b0010;
	// useEffect需要触发回调
	const HookHasEffect = 0b0001;

	let currentlyRenderingFiber = null;
	/**
	 * @param workInProgressHook 指向链表中当前正在处理的 Hook, 指向链表的尾部 (Fiber.memoizedState = workInProgressHook)
	 */
	let workInProgressHook = null;
	/**
	 * @param currentHook 指向上一次渲染的 Hook 链表中，与当前正在处理的这个 Hook 调用相对应的那个 Hook 对象
	 */
	let currentHook = null;
	let renderLane = NoLane;
	const { currentDispatcher } = internals;
	/**
	 * @description 执行一个函数式组件 (Function Component) 并获取它渲染出来的内容
	 * @param wip 是 FunctionComponent 类型的fibernode
	 * @return 返回函数组件执行后产生的子 React 元素 (children)
	 */
	function renderWithHooks(wip, lane) {
	    // 赋值操作
	    // 目的：hook要知道自身数据保存在哪里
	    // 作用：记录当前正在render的FC对应的fiberNode，在fiberNode中保存hook数据
	    currentlyRenderingFiber = wip;
	    // 重置 hooks链表
	    wip.memoizedState = null;
	    // 重置 effect链表
	    wip.updateQueue = null;
	    renderLane = lane;
	    const current = wip.alternate;
	    if (current !== null) {
	        // update
	        currentDispatcher.current = HooksDispatcherOnUpdate;
	    }
	    else {
	        // mount
	        currentDispatcher.current = HooksDispatcherOnMount;
	    }
	    // wip.type: 这个 type 属性对于函数式组件来说，就是那个组件函数本身
	    const Component = wip.type;
	    const props = wip.pendingProps;
	    // FC render
	    const children = Component(props);
	    // 重置操作
	    currentlyRenderingFiber = null;
	    workInProgressHook = null;
	    currentHook = null;
	    renderLane = NoLane;
	    return children;
	}
	const HooksDispatcherOnMount = {
	    useState: mountState,
	    useEffect: mountEffect
	};
	const HooksDispatcherOnUpdate = {
	    useState: updateState,
	    useEffect: updateEffect
	};
	/**
	 * @description useEffect Hook 在组件首次挂载时的实现
	 * @param create 用户传入的 useEffect 的第一个参数，即副作用的创建函数
	 * @param deps 用户传入的 useEffect 的第二个参数，即依赖项数组 (可选)
	 */
	function mountEffect(create, deps) {
	    // 获取这次 useEffect 调用的 Hook 对象
	    const hook = mountWorkInProgresHook();
	    const nextDeps = deps === undefined ? null : deps;
	    // 在当前正在渲染的 FiberNode 上打上 PassiveEffect
	    currentlyRenderingFiber.flags |= PassiveEffect;
	    // 创建并存储 Effect 对象
	    hook.memoizedState = pushEffect(Passive | HookHasEffect, create, undefined, nextDeps);
	}
	/**
	 * @function updateEffect
	 * @description `useEffect` Hook 在组件更新阶段的实现。
	 *              它会比较新的依赖项与上一次渲染时的依赖项：
	 *              - 如果依赖项没有变化，它仍然会创建一个新的 Effect 对象来保留上一次的销毁函数和依赖项信息，
	 *                但这个 Effect 对象不会被打上 `HookHasEffect` 标记，因此其创建函数不会在本次提交中执行。
	 *              - 如果依赖项发生了变化（或者没有提供依赖项数组，意味着每次渲染都执行），
	 *                当前组件的 FiberNode 会被打上 `PassiveEffect` 标记，
	 *                并且会创建一个新的 Effect 对象，该对象带有 `HookHasEffect` 标记，
	 *                其创建函数将在本次提交后执行。新的 Effect 对象会保留上一次的销毁函数，
	 *                以便在执行新的创建函数之前调用。
	 *
	 * @param {EffectCallback | void} create - 用户传入的 `useEffect` 的第一个参数，即副作用的创建函数。
	 * @param {EffectDeps | void} deps - 用户传入的 `useEffect` 的第二个参数，即依赖项数组 (可选)。
	 */
	function updateEffect(create, deps) {
	    const hook = updateWorkInProgresHook();
	    const nextDeps = deps === undefined ? null : deps;
	    let destroy;
	    if (currentHook !== null) {
	        const prevEffect = currentHook.memoizedState;
	        destroy = prevEffect.destroy;
	        if (nextDeps !== null) {
	            // 浅比较依赖
	            const prevDeps = prevEffect.deps;
	            if (areHookInputsEqual(nextDeps, prevDeps)) {
	                hook.memoizedState = pushEffect(Passive, create, destroy, nextDeps);
	                return;
	            }
	        }
	        // 浅比较 不相等
	        currentlyRenderingFiber.flags |= PassiveEffect;
	        hook.memoizedState = pushEffect(Passive | HookHasEffect, create, destroy, nextDeps);
	    }
	}
	/**
	 * @function areHookInputsEqual
	 * @description 浅比较两个依赖项数组 (`EffectDeps`) 是否相等。
	 * @param {EffectDeps} nextDeps - 新的依赖项数组。`EffectDeps` 类型通常是 `any[] | null`。
	 * @param {EffectDeps} prevDeps - 上一次渲染时的依赖项数组。
	 * @returns {boolean} 如果两个依赖项数组被认为是相等的，则返回 `true`；否则返回 `false`。
	 */
	function areHookInputsEqual(nextDeps, prevDeps) {
	    if (prevDeps === null || nextDeps === null) {
	        return false;
	    }
	    for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
	        if (Object.is(prevDeps[i], nextDeps[i])) {
	            continue;
	        }
	        return false;
	    }
	    return true;
	}
	/**
	 * @description 创建一个新的 Effect 对象，并将其添加到当前 FiberNode 的 Effect 链表的末尾。
	 * @param hookFlags Effect 的标记 (例如 Passive | HookHasEffect)。
	 * @param create 副作用的创建函数。
	 * @param destroy 副作用的销毁函数 (在挂载时通常是 undefined)。
	 * @param deps 依赖项数组。
	 * @returns 返回新创建的 Effect 对象。
	 */
	function pushEffect(hookFlags, create, destroy, deps) {
	    const effect = {
	        tag: hookFlags,
	        create,
	        destroy,
	        deps,
	        next: null
	    };
	    const fiber = currentlyRenderingFiber;
	    const updateQueue = fiber.updateQueue;
	    if (updateQueue === null) {
	        // // 如果当前 FiberNode 还没有 updateQueue
	        const updateQueue = createFCUpdateQueue();
	        fiber.updateQueue = updateQueue;
	        effect.next = effect;
	        updateQueue.lastEffect = effect;
	    }
	    else {
	        // 如果 updateQueue 已经存在
	        // 插入effect
	        const lastEffect = updateQueue.lastEffect;
	        if (lastEffect === null) {
	            effect.next = effect;
	            updateQueue.lastEffect = effect;
	        }
	        else {
	            const firstEffect = lastEffect.next;
	            lastEffect.next = effect;
	            effect.next = firstEffect;
	            updateQueue.lastEffect = effect;
	        }
	    }
	    return effect;
	}
	function createFCUpdateQueue() {
	    const updateQueue = createUpdateQueue();
	    updateQueue.lastEffect = null;
	    return updateQueue;
	}
	/**
	 * @description
	 * * 联系：当一个已经挂载的组件因为状态变化或其他原因需要重新渲染时，它内部的 useState 调用就会走到这个
	 * * 流程：
	 * 	* 找到当前这个 useState 调用在上一次渲染时对应的状态数据。
	 * 	* 检查是否有新的状态更新请求（即，是否调用了 setState）。
	 * 	* 如果有，则计算出新的状态。
	 * 	* 返回最新的状态值和对应的 setState 函数。
	 * @returns
	 */
	function updateState() {
	    // 找到当前useState对应的hook数据
	    const hook = updateWorkInProgresHook();
	    // 计算新state的逻辑
	    const queue = hook.updateQueue;
	    const pending = queue.shared.pending;
	    queue.shared.pending = null;
	    if (pending !== null) {
	        const { memoizedState } = processUpdateQueue(hook.memoizedState, pending, renderLane);
	        hook.memoizedState = memoizedState;
	    }
	    return [hook.memoizedState, queue.dispatch];
	}
	/**
	 * @description
	 * * 作用：
	 * 	* 找到旧 Hook
	 * 	* 创建新 Hook
	 * 	* 维护 Hook 链表
	 * 	* 错误检测
	 * * 什么时候触发：
	 * 	* 交互阶段 onClick
	 * 	* render阶段 （TODO）
	 * @returns
	 */
	function updateWorkInProgresHook() {
	    // TODO render阶段触发的更新 (这个注释可能指未来需要处理在渲染阶段直接触发更新的复杂情况)
	    let nextCurrentHook; // 用来存储从上一次渲染的 Hook 链表中找到的、与当前 Hook 调用对应的那个 Hook 对象
	    // 1. 确定当前应该处理哪个 "current" Hook (来自上一次渲染的 Hook)
	    if (currentHook === null) {
	        // 这是这个函数组件在本次 update 过程中的第一个 Hook 调用
	        // currentHook 是一个模块级变量，用于在遍历一个组件的多个 Hook 时，追踪上一次渲染中对应的 Hook 链表的当前位置。
	        // 如果它是 null，说明我们正要处理这个组件的第一个 Hook。
	        const current = currentlyRenderingFiber?.alternate; // 获取上一次渲染完成的 Fiber 节点 (current tree)
	        if (current !== null) {
	            // 如果存在上一次渲染的 Fiber 节点 (即不是首次挂载后的第一次更新，而是后续的更新)
	            nextCurrentHook = current?.memoizedState; // 函数组件的 Fiber 节点的 `memoizedState` 属性指向其 Hook 链表的头节点。
	            // 所以，这里获取的是上一次渲染时该组件的第一个 Hook 对象。
	        }
	        else {
	            // mount (理论上这个分支不应该在 updateWorkInProgresHook 中被走到)
	            // 因为 `renderWithHooks` 函数在 `current === null` (mount 阶段) 时，
	            // 会将 `currentDispatcher.current` 设置为 `HooksDispatcherOnMount`，
	            // 从而调用 `mountState` 和 `mountWorkInProgresHook`。
	            // 如果 `current !== null` (update 阶段)，才会设置为 `HooksDispatcherOnUpdate`，
	            // 进而调用 `updateState` 和 `updateWorkInProgresHook`。
	            // 所以，如果在这里 `current` 为 `null`，可能表示逻辑上的一个问题或未覆盖的边界情况。
	            // 但基于 `renderWithHooks` 的逻辑，`current` 在这里应该总是不为 `null`。
	            nextCurrentHook = null;
	        }
	    }
	    else {
	        // 这不是本次 update 过程中的第一个 Hook 调用，而是后续的 Hook 调用。
	        // `currentHook` 此时指向的是上一次渲染中、与上一个已处理的 Hook 相对应的那个 Hook 对象。
	        nextCurrentHook = currentHook.next; // 移动到上一次渲染的 Hook 链表中的下一个 Hook 对象。
	    }
	    // 2. 检查 Hook 调用顺序是否一致
	    if (nextCurrentHook === null) {
	        // 如果 `nextCurrentHook` 为 `null`，意味着：
	        // - 情况1 (mount/update u1 u2 u3 / update u1 u2 u3 u4):
	        //   上一次渲染有 N 个 Hook，但本次渲染尝试获取第 N+1 个 Hook，说明本次渲染比上次多调用了 Hook。
	        //   这是不允许的，违反了 Hooks 的规则 (Hooks must be called in the same order each time a component renders)。
	        throw new Error(`组件${currentlyRenderingFiber?.type}本次执行时的Hook比上次执行时多`);
	    }
	    // 3. 更新 currentHook 指针，并创建新的 work-in-progress Hook
	    currentHook = nextCurrentHook; // 将 `currentHook` 指向从旧链表中找到的当前 Hook。
	    // 现在 `currentHook` 是新 Hook 的数据来源。
	    const newHook = {
	        // 创建一个新的 Hook 对象，用于本次渲染 (work-in-progress tree)
	        memoizedState: currentHook.memoizedState, // 复制上一次渲染的状态值
	        updateQueue: currentHook.updateQueue, // 复制上一次渲染的更新队列引用
	        next: null // next 指针暂时为 null，如果后面还有 Hook，会被连接上
	    };
	    // 4. 将新的 Hook 对象链接到 work-in-progress Fiber 的 Hook 链表中
	    if (workInProgressHook === null) {
	        if (currentlyRenderingFiber === null) {
	            // 安全检查：Hooks 必须在函数组件内部调用。
	            throw new Error('请在函数组件内调用hook');
	        }
	        else {
	            workInProgressHook = newHook; // `workInProgressHook` 指向这个新创建的 Hook (它现在是链表尾部)
	            // 将 work-in-progress Fiber 的 `memoizedState` 指向这个新 Hook (它也是链表头部)
	            currentlyRenderingFiber.memoizedState = workInProgressHook;
	        }
	    }
	    else {
	        // 这不是第一个 Hook，将新 Hook 连接到链表的末尾
	        workInProgressHook.next = newHook; // 将前一个 work-in-progress Hook 的 next 指向这个新 Hook
	        workInProgressHook = newHook; // 更新 `workInProgressHook`，使其指向新的链表尾部
	    }
	    return workInProgressHook; // 返回新创建并链接好的 Hook 对象
	}
	/**
	 * @description useState Hook 在组件首次挂载时的实现。
	 * @param initialState 初始状态值，或者一个计算初始状态的函数。
	 * @returns 数组 [state, setState]
	 */
	function mountState(initialState // 初始状态值，或者一个计算初始状态的函数
	) {
	    // 1. 获取或创建专属于这次 useState 调用的 Hook 对象。
	    //    `mountWorkInProgresHook` 函数会确保我们为这个组件的 Hook 链表
	    //    准备好一个“坑位”（一个 Hook 对象）。这个“坑位”会用来存放
	    //    *当前这次* useState 调用所需的状态和更新队列。
	    const hook = mountWorkInProgresHook();
	    let memoizedState;
	    if (initialState instanceof Function) {
	        // 如果 `initialState` 是一个函数 (比如 useState(() => computeExpensiveValue()))，
	        // 就调用它来获取真正的初始状态。这是为了实现“惰性初始化”。
	        memoizedState = initialState();
	    }
	    else {
	        // 否则，`initialState` 就是直接给定的初始值。
	        memoizedState = initialState;
	    }
	    const queue = createUpdateQueue();
	    hook.updateQueue = queue;
	    hook.memoizedState = memoizedState;
	    // 创建 dispatch 函数 (也就是我们常说的 `setState` 函数)。
	    // @ts-ignore
	    const dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
	    // 将 dispatch 函数关联到它的队列上。
	    queue.dispatch = dispatch;
	    return [memoizedState, dispatch];
	}
	/**
	 * @description 当你调用由 useState 返回的那个用于更新状态的函数时，最终就会执行到这个 dispatchSetState。
	 * 1. 打包更新请求
	 * 2. 把更新请求放入队列
	 * 3. 触发重新渲染
	 */
	function dispatchSetState(fiber, updateQueue, action) {
	    const lane = requestUpdateLane();
	    const update = createUpdate(action, lane);
	    // 2. 把这个 'Update' 对象加入到 Hook 的更新队列中。
	    enqueueUpdate(updateQueue, update);
	    // 3. 为这个组件安排一次重新渲染。
	    scheduleUpdateOnFiber(fiber, lane);
	}
	/**
	 * @description 在函数组件的初始挂载阶段，创建一个 Hook 对象，并插入到链表中
	 * @returns 返回新创建并链接好的 Hook 对象（空的）。
	 */
	function mountWorkInProgresHook() {
	    const hook = {
	        memoizedState: null,
	        updateQueue: null,
	        next: null
	    };
	    // 函数组件的第一个 Hook
	    if (workInProgressHook === null) {
	        // 这是这个函数组件里的第一个 Hook (比如第一次调用 useState)。
	        if (currentlyRenderingFiber === null) {
	            // 如果不是，那就有问题了 —— Hook 只能在函数组件内部调用。
	            throw new Error('请在函数组件内调用hook');
	        }
	        else {
	            workInProgressHook = hook;
	            currentlyRenderingFiber.memoizedState = workInProgressHook;
	        }
	    }
	    else {
	        // 不是这个函数组件里的第一个 Hook
	        // 我们需要把这个新的 `hook` 连接到现有 Hook 链条的末尾。
	        workInProgressHook.next = hook;
	        workInProgressHook = hook;
	    }
	    return workInProgressHook;
	}

	// 递归中的递阶段 (这个注释准确地描述了 beginWork 的角色)
	/**
	 * @description "递"阶段的入口函数。根据 Fiber 节点的类型，
	 *              执行相应的更新逻辑，协调其子节点，并返回下一个要处理的 Fiber 节点。
	 * @param wip 当前正在处理的 work-in-progress Fiber 节点。
	 * @param renderLane 当前渲染的优先级。
	 * @returns 返回下一个要处理的 Fiber 节点 (通常是 wip 的第一个子节点)，或者 null。
	 */
	const beginWork = (wip, renderLane) => {
	    switch (wip.tag) {
	        case HostRoot:
	            return updateHostRoot(wip, renderLane);
	        case HostComponent:
	            return updateHostComponent(wip);
	        case HostText:
	            return null;
	        case FunctionComponent:
	            return updateFunctionComponent(wip, renderLane);
	        case Fragment:
	            return updateFragment(wip);
	        default:
	            {
	                console.warn('beginWork未实现的类型');
	            }
	            break;
	    }
	    return null;
	};
	/**
	 * @description 处理 Fragment 类型的 Fiber 节点
	 * @param wip 父节点
	 * @returns 返回协调后产生的第一个子 Fiber 节点
	 */
	function updateFragment(wip) {
	    const nextChildren = wip.pendingProps;
	    reconcileChildren(wip, nextChildren);
	    return wip.child;
	}
	/**
	 * @description 处理 Function Component 类型的 Fiber 节点
	 * @param wip 父节点
	 * @returns 返回协调后产生的第一个子 Fiber 节点
	 */
	function updateFunctionComponent(wip, renderLane) {
	    const nextChildren = renderWithHooks(wip, renderLane);
	    reconcileChildren(wip, nextChildren);
	    return wip.child;
	}
	/**
	 * @description 处理整个应用的根节点（即HostRoot Fiber）的更新队列
	 * @param wip 父节点
	 * @returns 返回协调后产生的第一个子 Fiber 节点
	 */
	function updateHostRoot(wip, renderLane) {
	    const baseState = wip.memoizedState;
	    const updateQueue = wip.updateQueue;
	    const pending = updateQueue.shared.pending;
	    updateQueue.shared.pending = null;
	    // memoizedState：当前的hostRoot的最新的状态
	    const { memoizedState } = processUpdateQueue(baseState, pending, renderLane);
	    wip.memoizedState = memoizedState;
	    // nextChildren: 子节点的reactElement
	    const nextChildren = wip.memoizedState;
	    // 对比子节点 current fiberNode与子节点 reactElement，生成子节点对应wip fiberNode
	    reconcileChildren(wip, nextChildren);
	    return wip.child;
	}
	/**
	 * @description 处理 Host Component 类型的 Fiber 节点
	 * @param wip 父节点
	 * @returns 返回协调后产生的第一个子 Fiber 节点
	 */
	function updateHostComponent(wip) {
	    const nextProps = wip.pendingProps;
	    const nextChildren = nextProps.children;
	    reconcileChildren(wip, nextChildren);
	    return wip.child;
	}
	/**
	 * @description 是一个调度函数。它根据当前父节点是首次挂载还是更新，来调用两个专门的子节点协调函数之一，最终的结果是，wip.child 会指向其新协调好的子 Fiber 节点链表的头部
	 * @param wip wip父节点
	 * @param children 子节点 reactElement
	 */
	function reconcileChildren(wip, children) {
	    const current = wip.alternate;
	    if (current !== null) {
	        // update
	        wip.child = reconcileChildFibers(wip, current?.child, children);
	    }
	    else {
	        // mount
	        wip.child = mountChildFibers(wip, null, children);
	    }
	}

	let instanceCounter = 0;
	// export const createInstance = (type: string, props: any): Instance => {
	const createInstance = (type, props) => {
	    const instance = {
	        id: instanceCounter++,
	        type,
	        children: [],
	        parent: -1,
	        props
	    };
	    return instance;
	};
	const appendInitialChild = (parent, child) => {
	    // id
	    const prevParentID = child.parent;
	    const parentID = 'rootID' in parent ? parent.rootID : parent.id;
	    if (prevParentID !== -1 && prevParentID !== parentID) {
	        throw new Error('不能重复挂载child');
	    }
	    child.parent = parentID;
	    parent.children.push(child);
	};
	const createTextInstance = (content) => {
	    const instance = {
	        text: content,
	        id: instanceCounter++,
	        parent: -1
	    };
	    return instance;
	};
	const appendChildToContainer = (parent, child) => {
	    // id
	    const prevParentID = child.parent;
	    if (prevParentID !== -1 && prevParentID !== parent.rootID) {
	        throw new Error('不能重复挂载child');
	    }
	    child.parent = parent.rootID;
	    parent.children.push(child);
	};
	function commitUpdate(fiber) {
	    switch (fiber.tag) {
	        case HostText:
	            const text = fiber.memoizedProps?.content;
	            return commitTextUpdate(fiber.stateNode, text);
	        default:
	            {
	                console.warn('未实现的Update类型', fiber);
	            }
	            break;
	    }
	}
	function commitTextUpdate(textInstance, content) {
	    textInstance.text = content;
	}
	function removeChild(child, container) {
	    const index = container.children.indexOf(child);
	    if (index === -1) {
	        throw new Error('child不存在');
	    }
	    container.children.splice(index, 1);
	}
	function insertChildToContainer(child, container, before) {
	    const beforeIndex = container.children.indexOf(before);
	    if (beforeIndex === -1) {
	        throw new Error('before不存在');
	    }
	    const index = container.children.indexOf(child);
	    if (index !== -1) {
	        container.children.splice(index, 1);
	    }
	    container.children.splice(beforeIndex, 0, child);
	}
	const scheduleMicroTask = typeof queueMicrotask === 'function'
	    ? queueMicrotask
	    : typeof Promise === 'function'
	        ? (callback) => Promise.resolve(null).then(callback)
	        : setTimeout;

	let nextEffect = null;
	/**
	 * @description 遍历这棵 finishedWork Fiber 树，并执行所有与 DOM 结构变更相关的副作用
	 * * Placement (插入)：将新的 DOM 节点添加到页面上。
	 * * Update (更新)：修改现有 DOM 节点的属性或文本内容。
	 * * ChildDeletion (子节点删除)：从 DOM 中移除不再需要的节点
	 * @param finishedWork
	 * @param root
	 */
	const commitMutationEffects = (finishedWork, root) => {
	    // 1. 初始化一个全局（或模块作用域）变量 nextEffect，
	    //    将其指向传入的 finishedWork (通常是完成了协调工作的 Fiber 树的根节点，或者某个子树的根)。
	    //    nextEffect 将作为遍历 Fiber 树以执行副作用的游标。
	    nextEffect = finishedWork;
	    // 2. 开始一个循环，只要 nextEffect 不为 null，就继续遍历。
	    while (nextEffect !== null) {
	        // 3. "向下遍历" 逻辑：
	        //    获取当前 nextEffect 节点的第一个子节点。
	        const child = nextEffect.child;
	        // 4. 检查当前 nextEffect 节点的子树中是否存在“变更类”副作用，并且它有子节点。
	        //    (nextEffect.subtreeFlags & MutationMask) !== NoFlags:
	        //        - nextEffect.subtreeFlags 记录了该节点整个子树中所有副作用的标记。
	        //        - MutationMask 是一个掩码，包含了所有变更类副作用的标记 (如 Placement, Update, ChildDeletion)。
	        //        - 这个条件判断 nextEffect 的子树中是否包含任何需要执行的 DOM 变更操作。
	        //    child !== null: 确保有子节点可以向下遍历。
	        if ((nextEffect.subtreeFlags & (MutationMask | PassiveMask)) !== NoFlags &&
	            child !== null) {
	            // 5. 如果子树中有变更，并且有子节点，则将 nextEffect 指向其第一个子节点，
	            //    实现向下深入遍历。
	            nextEffect = child;
	        }
	        else {
	            // 6. "向上遍历 DFS" (深度优先搜索的回溯阶段) 逻辑：
	            //    如果当前节点的子树没有变更，或者当前节点没有子节点，
	            //    就需要处理当前节点自身的副作用，然后尝试移动到兄弟节点或向上回溯。
	            up: while (nextEffect !== null) {
	                // 7. 对当前的 nextEffect 节点执行其自身的变更类副作用。
	                //    commitMutaitonEffectsOnFiber 函数会检查 nextEffect.flags，
	                //    并执行相应的 Placement, Update, 或 ChildDeletion 操作。
	                commitMutaitonEffectsOnFiber(nextEffect, root);
	                // 8. 获取当前 nextEffect 节点的兄弟节点。
	                const sibling = nextEffect.sibling;
	                // 9. 如果存在兄弟节点
	                if (sibling !== null) {
	                    // 10. 将 nextEffect 指向兄弟节点，
	                    //     以便在下一次外层 while 循环中开始处理这个兄弟分支。
	                    nextEffect = sibling;
	                    // 11. 使用 break up; 跳出内部的 'up' 标签的 while 循环，
	                    //     回到外层 while (nextEffect !== null) 继续。
	                    break up;
	                }
	                // 12. 如果没有兄弟节点，将 nextEffect 指向其父节点 (nextEffect.return)，
	                //     实现向上回溯。内部的 'up' while 循环会继续，
	                //     在父节点上执行 commitMutaitonEffectsOnFiber，然后再检查父节点的兄弟节点。
	                nextEffect = nextEffect.return;
	            }
	            // 13. 当内部的 'up' while 循环因为 nextEffect 最终变为 null (回溯到树顶并处理完毕)
	            //     而自然结束时，外层的 while (nextEffect !== null) 也会终止。
	        }
	    }
	};
	/**
	 * @description 针对单个 Fiber 节点来执行其身上标记的“变更类”副作用（Mutation Effects）。“变更类”副作用指的是那些会直接修改 DOM 结构的操作，比如插入新节点、更新现有节点、删除节点。
	 * @param finishedWork 当前有flags的节点
	 */
	const commitMutaitonEffectsOnFiber = (finishedWork, root) => {
	    // 1. 获取当前 finishedWork Fiber 节点的副作用标记 (flags)
	    const flags = finishedWork.flags;
	    // 2. 检查是否包含 Placement (放置/插入) 标记
	    //    (flags & Placement) !== NoFlags 表示 flags 中存在 Placement 位
	    if ((flags & Placement) !== NoFlags) {
	        // 3. 如果有 Placement 标记，调用 commitPlacement 函数来执行 DOM 插入操作
	        commitPlacement(finishedWork);
	        // 4. 执行完 Placement 操作后，从 finishedWork.flags 中移除 Placement 标记
	        //    finishedWork.flags &= ~Placement; (按位与上 Placement 的反码)
	        //    这样做是为了防止在后续的遍历或处理中重复执行该副作用。
	        finishedWork.flags &= -2;
	    }
	    // 5. 检查是否包含 Update (更新) 标记
	    if ((flags & Update) !== NoFlags) {
	        // 6. 如果有 Update 标记，调用 commitUpdate 函数 (来自 hostConfig)
	        //    来执行 DOM 元素的属性更新或文本节点的文本内容更新。
	        commitUpdate(finishedWork);
	        // 7. 执行完 Update 操作后，移除 Update 标记。
	        finishedWork.flags &= -3;
	    }
	    // 8. 检查是否包含 ChildDeletion (子节点删除) 标记
	    if ((flags & ChildDeletion) !== NoFlags) {
	        const deletions = finishedWork.deletions;
	        if (deletions !== null) {
	            deletions.forEach((childToDelete) => {
	                commitDeletion(childToDelete, root);
	            });
	        }
	        finishedWork.flags &= -5;
	    }
	    if ((flags & PassiveEffect) !== NoFlags) {
	        // 收集回调
	        commitPassiveEffect(finishedWork, root, 'update');
	        finishedWork.flags &= -9;
	    }
	};
	/**
	 * @description 收集函数组件中需要执行的被动副作用 (useEffect)，
	 *              并将它们添加到 FiberRootNode 的 pendingPassiveEffects 队列中。
	 * @param fiber 当前正在处理的 Fiber 节点。
	 * @param root FiberRootNode，代表整个应用的根。
	 * @param type 'update' 或 'unmount'，指示当前是处理更新时的副作用还是卸载时的副作用。
	 */
	function commitPassiveEffect(fiber, root, type) {
	    // update unmount
	    if (fiber.tag !== FunctionComponent ||
	        (type === 'update' && (fiber.flags & PassiveEffect) === NoFlags)) {
	        return;
	    }
	    const updateQueue = fiber.updateQueue;
	    if (updateQueue !== null) {
	        if (updateQueue.lastEffect === null && true) {
	            console.error('当FC存在PassiveEffect flag时，不应该不存在effect');
	        }
	        root.pendingPassiveEffects[type].push(updateQueue.lastEffect);
	    }
	}
	/**
	 * @function commitHookEffectList
	 * @description 遍历一个 Effect 对象的循环链表，并对链表中那些 `tag` 属性
	 *              与传入的 `flags` 参数匹配的 Effect 对象执行一个指定的回调函数。
	 *              这个函数是处理 useEffect Hook 副作用（如执行创建或销毁函数）的通用辅助函数。
	 *
	 * @param {Flags} flags - 一个位掩码，用于筛选需要处理的 Effect 对象。
	 *                        只有当 Effect 对象的 `tag` 属性通过按位与操作 (`&`)
	 *                        包含所有在 `flags` 中设置的位时，该 Effect 对象才会被处理。
	 *                        例如，如果 flags 是 `Passive | HookHasEffect`，则只有同时具有
	 *                        `Passive` 和 `HookHasEffect` 标记的 Effect 对象才会匹配。
	 * @param {Effect} lastEffect - Effect 循环链表中的最后一个 Effect 对象。
	 *                              函数会从 `lastEffect.next` (即链表的第一个 Effect) 开始遍历。
	 *                              这个链表通常存储在函数组件 FiberNode 的 `updateQueue.lastEffect` 中。
	 * @param {(effect: Effect) => void} callback - 一个回调函数，它会接收每个匹配条件的 Effect 对象作为参数。
	 *                                             这个回调函数负责执行具体的操作，例如调用 Effect 的
	 *                                             `create` 或 `destroy` 方法。
	 */
	function commitHookEffectList(flags, lastEffect, callback) {
	    let effect = lastEffect.next;
	    do {
	        if ((effect.tag & flags) === flags) {
	            callback(effect);
	        }
	        effect = effect.next;
	    } while (effect !== lastEffect.next);
	}
	/**
	 * @function commitHookEffectListUnmount
	 * @description 遍历 Effect 循环链表，执行所有匹配指定 `flags` (通常是 `Passive`) 的 Effect 对象的销毁函数。
	 *              这个函数主要用于组件卸载时，清理所有相关的 `useEffect` 副作用。
	 *              在执行销毁函数后，它还会从 Effect 的 `tag` 中移除 `HookHasEffect` 标记，
	 *              表示该 Effect 的销毁回调已被处理。
	 *
	 * @param {Flags} flags - 用于筛选需要执行销毁回调的 Effect 对象的标记。
	 *                        通常是 `Passive`，表示处理所有被动副作用的销毁。
	 * @param {Effect} lastEffect - Effect 循环链表中的最后一个 Effect 对象。
	 */
	function commitHookEffectListUnmount(flags, lastEffect) {
	    commitHookEffectList(flags, lastEffect, (effect) => {
	        const destroy = effect.destroy;
	        if (typeof destroy === 'function') {
	            destroy();
	        }
	        effect.tag &= -2;
	    });
	}
	/**
	 * @function commitHookEffectListDestroy
	 * @description 遍历 Effect 循环链表，执行所有匹配指定 `flags` (通常是 `Passive | HookHasEffect`)
	 *              的 Effect 对象的销毁函数。
	 *              这个函数主要用于 `useEffect` 依赖项发生变化，需要先清理旧的副作用，
	 *              然后再执行新的副作用创建函数的场景。
	 *              它只执行销毁函数，不修改 Effect 的 `tag`。
	 *
	 * @param {Flags} flags - 用于筛选需要执行销毁回调的 Effect 对象的标记。
	 *                        通常是 `Passive | HookHasEffect`，表示处理那些在本次更新中
	 *                        需要被重新触发（因此旧的需要销毁）的被动副作用。
	 * @param {Effect} lastEffect - Effect 循环链表中的最后一个 Effect 对象。
	 */
	function commitHookEffectListDestroy(flags, lastEffect) {
	    commitHookEffectList(flags, lastEffect, (effect) => {
	        const destroy = effect.destroy;
	        if (typeof destroy === 'function') {
	            destroy();
	        }
	    });
	}
	/**
	 * @function commitHookEffectListCreate
	 * @description 遍历 Effect 循环链表，执行所有匹配指定 `flags` (通常是 `Passive | HookHasEffect`)
	 *              的 Effect 对象的创建函数。
	 *              这个函数主要用于组件首次挂载或 `useEffect` 依赖项发生变化，需要执行新的副作用创建函数的场景。
	 *              执行创建函数后，如果创建函数返回了一个清理函数，该清理函数会被赋值给 Effect 对象的 `destroy` 属性。
	 *
	 * @param {Flags} flags - 用于筛选需要执行创建回调的 Effect 对象的标记。
	 *                        通常是 `Passive | HookHasEffect`，表示处理那些在本次更新中
	 *                        需要被触发的被动副作用。
	 * @param {Effect} lastEffect - Effect 循环链表中的最后一个 Effect 对象。
	 */
	function commitHookEffectListCreate(flags, lastEffect) {
	    commitHookEffectList(flags, lastEffect, (effect) => {
	        const create = effect.create;
	        if (typeof create === 'function') {
	            effect.destroy = create();
	        }
	    });
	}
	/**
	 * @description 收集一个列表，这个列表包含了那些互为兄弟节点、并且是需要从它们共同的 DOM 父节点中被显式移除的直接 Host 子 Fiber 节点
	 * @param childrenToDelete 一个数组（从 commitDeletion 通过引用传递过来），用于累积需要删除的宿主 Fiber 节点
	 * @param unmountFiber
	 */
	function recordHostChildrenToDelete(childrenToDelete, unmountFiber) {
	    // 1. 找到第一个root host节点
	    const lastOne = childrenToDelete[childrenToDelete.length - 1];
	    if (!lastOne) {
	        childrenToDelete.push(unmountFiber);
	    }
	    else {
	        let node = lastOne.sibling;
	        while (node !== null) {
	            if (unmountFiber === node) {
	                childrenToDelete.push(unmountFiber);
	            }
	            node = node.sibling;
	        }
	    }
	    // 2. 每找到一个 host节点，判断下这个节点是不是 1 找到那个节点的兄弟节点
	}
	/**
	 * @description 这个函数负责完整地卸载一个 Fiber 节点 (childToDelete) 及其整个子树
	 * * 执行清理逻辑
	 * * 从 DOM 中移除
	 * * 断开 Fiber 链接
	 * @param childToDelete
	 */
	function commitDeletion(childToDelete, root) {
	    const rootChildrenToDelete = [];
	    // 递归子树
	    commitNestedComponent(childToDelete, (unmountFiber) => {
	        switch (unmountFiber.tag) {
	            case HostComponent: // 如果是宿主组件 (如 <div>)
	                recordHostChildrenToDelete(rootChildrenToDelete, unmountFiber);
	                // TODO 解绑ref
	                return;
	            case HostText: // 如果是宿主文本节点
	                recordHostChildrenToDelete(rootChildrenToDelete, unmountFiber);
	                return;
	            case FunctionComponent: // 如果是函数组件
	                // TODO 解绑ref
	                commitPassiveEffect(unmountFiber, root, 'unmount');
	                return;
	            default:
	                {
	                    console.warn('未处理的unmount类型', unmountFiber);
	                }
	        }
	    });
	    // 5. 当 commitNestedComponent 执行完毕后，childToDelete 子树中所有节点的
	    //    卸载前清理逻辑 (如 componentWillUnmount, useEffect 清理) 应该已经执行。
	    //    现在，实际从 DOM 中移除节点。
	    if (rootChildrenToDelete.length) {
	        const hostParent = getHostParent(childToDelete);
	        if (hostParent !== null) {
	            rootChildrenToDelete.forEach((node) => {
	                removeChild(node.stateNode, hostParent);
	            });
	        }
	    }
	    childToDelete.return = null;
	    childToDelete.child = null;
	}
	/**
	 * @description 主要任务是深度优先遍历一个给定的 Fiber 子树（从 root 节点开始），并对子树中的每一个 Fiber 节点执行一个指定的回调函数 onCommitUnmount
	 * @param root 代表需要被卸载（unmount）的子树的根 Fiber 节点
	 * @param onCommitUnmount 一个回调函数，会对子树中的每个 Fiber 节点调用
	 * @returns
	 */
	function commitNestedComponent(root, onCommitUnmount) {
	    // 1. 初始化一个游标 node，指向子树的根节点 root
	    let node = root;
	    // 2. 开始一个无限循环，这个循环会通过内部的 return 语句来终止
	    while (true) {
	        // 3. 对当前遍历到的 node 调用 onCommitUnmount 回调函数。
	        //    这个回调函数通常用于执行一些卸载前的清理工作，
	        //    比如调用组件的 componentWillUnmount 生命周期方法，
	        //    或者执行 useEffect 的清理函数。
	        onCommitUnmount(node);
	        // 4. 检查当前 node 是否有子节点
	        if (node.child !== null) {
	            // 5. 如果有子节点，说明需要向下遍历。
	            //    确保子节点的 return 指针指向当前 node (其父节点)。
	            node.child.return = node;
	            //    将游标 node 移动到其子节点。
	            node = node.child;
	            //    使用 continue 跳过本次循环的后续部分，直接开始处理这个子节点。
	            continue;
	        }
	        // 6. 如果代码执行到这里，说明当前 node 没有子节点，或者其子节点都已被处理。
	        //    检查当前 node 是否就是最初传入的子树根节点 root。
	        if (node === root) {
	            // 7. 如果是，说明整个子树（从 root 开始向下）都已经遍历并调用了 onCommitUnmount。
	            //    此时，函数可以返回，表示卸载前的遍历和回调执行完毕。
	            return;
	        }
	        // 8. 如果当前 node 不是 root，并且它没有子节点，
	        //    那么我们需要尝试移动到它的兄弟节点，或者向上回溯。
	        //    这个内部循环处理向上回溯的逻辑。
	        while (node.sibling === null) {
	            // 9. 如果当前 node 没有兄弟节点，检查它的父节点 (node.return)。
	            //    如果父节点为 null (不应在此函数内发生，除非 root 本身是顶级节点且无父)，
	            //    或者父节点就是最初的 root 节点，
	            //    说明我们已经回溯到了子树的根部，并且该分支已处理完毕，函数可以返回。
	            if (node.return === null || node.return === root) {
	                return;
	            }
	            // 10. 如果不满足上述终止条件，将游标 node 移动到其父节点，实现向上回溯。
	            node = node.return;
	        }
	        // 11. 当从内部的 while 循环 (步骤 8-10) 跳出时，
	        //     说明当前 node (在回溯后) 找到了一个兄弟节点。
	        //     确保这个兄弟节点的 return 指针指向正确的父节点 (node.return)。
	        node.sibling.return = node.return;
	        // 12. 将游标 node 移动到这个兄弟节点，以便在下一次主循环 (步骤 2) 中处理这个兄弟分支。
	        node = node.sibling;
	    }
	}
	/**
	 * @description 专门用来处理带有 Placement 标记的 Fiber 节点的
	 * @param finishedWork
	 */
	const commitPlacement = (finishedWork) => {
	    {
	        console.warn('执行Placement操作', finishedWork);
	    }
	    // parent DOM
	    const hostParent = getHostParent(finishedWork);
	    // host sibling
	    const sibling = getHostSibling(finishedWork);
	    // finishedWork ~~ DOM append parent DOM
	    if (hostParent !== null) {
	        insertOrAppendPlacementNodeIntoContainer(finishedWork, hostParent, sibling);
	    }
	};
	/**
	 * @description 找到一个给定的 Fiber 节点在 DOM 结构中的下一个真实的兄弟 DOM 节点
	 * @param fiber
	 * @returns
	 */
	function getHostSibling(fiber) {
	    let node = fiber; // 游标
	    findSibling: while (true) {
	        // 向上查找，直到找到一个有兄弟节点的祖先，或者到达一个宿主类型的父节点或根节点
	        while (node.sibling === null) {
	            const parent = node.return;
	            if (parent === null ||
	                parent.tag === HostComponent ||
	                parent.tag === HostRoot) {
	                return null;
	            }
	            node = parent;
	        }
	        // 当跳出上面的内部 while 循环时，说明当前的 `node` 有一个 `sibling`
	        node.sibling.return = node.return;
	        // // 将游标 `node` 移动到这个兄弟节点
	        node = node.sibling;
	        // 向下查找，从这个兄弟节点开始，向下查找第一个实际的 DOM 节点
	        while (node.tag !== HostText && node.tag !== HostComponent) {
	            // 说明直接 sibling 不是一个 Host 类型
	            if ((node.flags & Placement) !== NoFlags) {
	                // 不稳定，继续找
	                continue findSibling;
	            }
	            if (node.child === null) {
	                continue findSibling;
	            }
	            else {
	                node.child.return = node;
	                node = node.child;
	            }
	        }
	        // 当跳出上面的内部 while 循环时，`node` 应该是一个 HostComponent 或 HostText 类型的 Fiber 节点
	        //    如果它没有 Placement 标记，说明它是一个已经存在于 DOM 中的稳定节点，
	        //    这就是我们要找的 DOM 兄弟节点，返回它的 `stateNode` (即真实的 DOM 元素或文本节点)。
	        if ((node.flags & Placement) === NoFlags) {
	            return node.stateNode;
	        }
	        // 如果这个找到的宿主节点本身也有 Placement 标记，说明它也是新插入的（不稳定的Host节点），
	        // 不能作为插入 `fiber` 时的 `before` 参照物。
	        // 此时，循环会回到 `findSibling` 的开头，继续尝试从 `node` (当前这个带 Placement 的宿主节点)
	        // 的兄弟节点开始查找，或者从其父节点的兄弟节点开始查找。
	    }
	}
	/**
	 * @description 从给定的 Fiber 节点开始，向上遍历 Fiber 树，直到找到第一个可以直接作为 DOM 父容器的祖先节点
	 * @param fiber
	 * @returns
	 */
	function getHostParent(fiber) {
	    let parent = fiber.return;
	    while (parent) {
	        const parentTag = parent.tag;
	        // HostComponent 比如代表一个 <div>、<span> 等 HTML 标签的 Fiber 节点
	        if (parentTag === HostComponent) {
	            return parent.stateNode;
	        }
	        // HostRoot 代表整个 React 应用的根节点的 Fiber
	        if (parentTag === HostRoot) {
	            return parent.stateNode.container;
	        }
	        parent = parent.return;
	    }
	    {
	        console.warn('未找到host parent');
	    }
	    return null;
	}
	/**
	 *
	 * @description 将一个指定的 Fiber 节点（finishedWork）所代表的真实 DOM 内容，追加到一个指定的父 DOM 容器（hostParent）中
	 * @param finishedWork 需要被放置的 Fiber 节点
	 * @param hostParent 目标父 DOM 容器
	 * @returns
	 */
	function insertOrAppendPlacementNodeIntoContainer(finishedWork, // 参数 finishedWork：代表需要被“放置”到 DOM 中的 Fiber 节点
	hostParent, // 参数 hostParent：这个 Fiber 节点应该被添加到的父级真实 DOM 容器
	before) {
	    // 1. 检查 finishedWork 是否是直接可以渲染到 DOM 的类型
	    //    即宿主组件 (HostComponent，如 <div>) 或宿主文本节点 (HostText)
	    if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
	        if (before) {
	            insertChildToContainer(finishedWork.stateNode, hostParent, before);
	        }
	        else {
	            appendChildToContainer(hostParent, finishedWork.stateNode);
	        }
	        return;
	    }
	    // 4. 如果 finishedWork 不是直接的宿主节点 (例如，它可能是一个函数组件 FunctionComponent)，
	    //    那么它本身不对应一个 DOM 元素。我们需要找到它渲染出来的实际 DOM 子孙节点。
	    //    获取 finishedWork 的第一个子 Fiber 节点。
	    const child = finishedWork.child;
	    // 5. 如果 finishedWork 有子节点 (child !== null)
	    if (child !== null) {
	        // 6. 递归调用 appendPlacementNodeIntoContainer，
	        //    尝试将第一个子节点 (child) 放置到同一个 hostParent 中。
	        //    这是因为如果父节点 (finishedWork) 是一个组件，那么它的子节点才是实际要渲染的内容。
	        insertOrAppendPlacementNodeIntoContainer(child, hostParent);
	        // 7. 处理第一个子节点之后，还需要处理它的所有兄弟节点。
	        //    获取第一个子节点的兄弟节点。
	        let sibling = child.sibling;
	        // 8. 循环遍历所有兄弟节点
	        while (sibling !== null) {
	            // 9. 对每个兄弟节点，同样递归调用 appendPlacementNodeIntoContainer，
	            //    将它们也放置到同一个 hostParent 中。
	            insertOrAppendPlacementNodeIntoContainer(sibling, hostParent);
	            // 10. 移动到下一个兄弟节点
	            sibling = sibling.sibling;
	        }
	    }
	    // 11. 如果 finishedWork 没有子节点 (例如一个没有返回任何内容的组件)，则此函数不执行任何操作。
	}

	/**
	 * @description 给传入的 fiber 节点的 flags 属性添加上 Update 标记。
	 * @param fiber wip fiber node
	 */
	function markUpdate(fiber) {
	    // |= 是按位或赋值操作，确保在不丢失原有 flags 的情况下添加新的 Update 标记。
	    fiber.flags |= Update;
	}
	/**
	 * @description -
	 * * 创建/更新 DOM 实例
	 * * 副作用标记冒泡
	 * @param wip
	 * @returns
	 */
	const completeWork = (wip) => {
	    const newProps = wip.pendingProps;
	    // 2. 获取与当前 wip Fiber 对应的 current Fiber (上一次渲染的 Fiber 节点). 如果 current 为 null，表示这是一个全新的节点 (挂载阶段)
	    const current = wip.alternate;
	    switch (wip.tag) {
	        case HostComponent:
	            if (current !== null && wip.stateNode) {
	                // TODO update
	                // 1. props是否变化 {onClick: xx} {onClick: xxx}
	                // 2. 变了 Update flag
	                // className style
	                markUpdate(wip);
	            }
	            else {
	                // 7. 挂载路径：如果是新节点
	                //    7a. 调用 hostConfig 中的 createInstance 函数，根据 wip.type (例如 "div")
	                //        创建一个真实的 DOM 元素实例。
	                const instance = createInstance(wip.type, newProps);
	                //    7b. 调用 appendAllChildren 函数，将 wip 节点的所有子孙后代中
	                //        实际的 DOM 节点（或文本节点）附加到刚刚创建的 instance (父DOM元素) 上。
	                appendAllChildren(instance, wip);
	                //    7c. 将创建的真实 DOM 元素实例保存在当前 wip Fiber 节点的 stateNode 属性上。
	                wip.stateNode = instance;
	            }
	            // 8. 调用 bubbleProperties 函数，将子节点的副作用标记冒泡到当前节点的 subtreeFlags。
	            bubbleProperties(wip);
	            // 9. completeWork 通常返回 null，表示当前 Fiber 节点的工作已经完成，
	            //    协调器应该继续处理其兄弟节点或父节点。
	            return null;
	        // 10. 如果是宿主文本节点 (HostText)
	        case HostText:
	            // 11. 检查是否是更新过程且真实 DOM 文本节点已创建
	            if (current !== null && wip.stateNode) {
	                // 12. 更新路径：
	                //     12a. 获取旧的文本内容。
	                const oldText = current.memoizedProps?.content;
	                //     12b. 获取新的文本内容。
	                const newText = newProps.content;
	                //     12c. 如果文本内容发生了变化，就调用 markUpdate 标记该 Fiber 节点，
	                //          以便在提交阶段更新真实 DOM 文本节点的内容。
	                if (oldText !== newText) {
	                    markUpdate(wip);
	                }
	            }
	            else {
	                // 13. 挂载路径：如果是新文本节点
	                //     13a. 调用 hostConfig 中的 createTextInstance 函数，
	                //          根据 newProps.content 创建一个真实的 DOM 文本节点实例。
	                const instance = createTextInstance(newProps.content);
	                //     13b. 将创建的文本节点实例保存在 stateNode 上。
	                wip.stateNode = instance;
	            }
	            // 14. 冒泡子节点的副作用标记 (对于文本节点，通常没有子节点，但保持一致性)
	            bubbleProperties(wip);
	            // 15. 返回 null
	            return null;
	        case HostRoot:
	        case FunctionComponent:
	        case Fragment:
	            bubbleProperties(wip);
	            return null;
	        // 22. 如果遇到未处理的 Fiber 类型
	        default:
	            // 23. 并且在开发环境 (true) 下，会打印一个警告。
	            {
	                console.warn('未处理的completeWork情况', wip);
	            }
	            // 24. 结束 switch 语句的这个 case
	            break;
	    }
	};
	/**
	 * @description
	 * * 主要任务是构建真实的 DOM 树层级关系
	 * * 遍历这个 wip 父 Fiber 节点的所有子孙后代 Fiber 节点，找到那些代表真实 DOM 元素或文本节点的 Fiber（即 HostComponent 或 HostText 类型的 Fiber），并将它们对应的真实 DOM 节点（存储在 stateNode 属性中）依次附加到 parent DOM 元素上。
	 * @param parent 真实 DOM 元素
	 * @param wip 该DOM元素对应的fiber-node
	 */
	function appendAllChildren(parent, wip) {
	    // 1. 从 wip (当前父 Fiber 节点) 的第一个子 Fiber 节点开始遍历
	    // node 作为遍历的指针
	    let node = wip.child;
	    // 2. 持续循环，直到 wip 的所有子孙节点都被处理完毕
	    while (node !== null) {
	        // 3. 检查当前遍历到的 node 是否是宿主组件 (HostComponent) 或宿主文本节点 (HostText)
	        if (node.tag === HostComponent || node.tag === HostText) {
	            // 4. 如果是，说明这个 node 对应一个真实的 DOM 元素或文本节点 (存储在 node.stateNode 中)
	            //    调用 appendInitialChild 函数 (来自 hostConfig)，
	            //    将这个真实的 DOM 节点 (node.stateNode) 添加为 parent (父 DOM 元素) 的子节点。
	            //    node?.stateNode 使用了可选链，以防 stateNode 意外为 null (虽然理论上此时不应为 null)。
	            appendInitialChild(parent, node?.stateNode);
	        }
	        else if (node.child !== null) {
	            // 5. 如果当前 node 不是直接的宿主节点 (例如，它可能是一个
	            // )，
	            //    并且它拥有自己的子节点 (node.child !== null)，
	            //    这意味着我们需要更深入地遍历这个 node 的子树，以找到可附加的真实 DOM 节点。
	            // 6. 确保这个更深层子节点的 return 指针指向其直接父 Fiber (node)。
	            //    这有助于维护 Fiber 树结构的正确性。
	            node.child.return = node;
	            // 7. 将 node 指向其子节点，实现向下遍历。
	            node = node.child;
	            // 8. 使用 continue 跳过本次循环的后续部分 (兄弟节点和回溯逻辑)，
	            //    直接从这个更深层的子节点开始新一轮的循环。
	            continue;
	        }
	        // 9. 这是一个安全检查或终止条件。如果 node 意外地变回了最初的 wip 父节点，
	        //    说明遍历可能出现了问题或已经完成，此时函数返回。
	        if (node === wip) {
	            return;
	        }
	        // 10. 如果当前 node 没有兄弟节点了 (node.sibling === null)，
	        //     意味着当前层级的子节点都处理完了，需要向上回溯到父节点，
	        //     然后尝试处理父节点的兄弟节点（即当前节点的“叔叔”节点）。
	        while (node.sibling === null) {
	            // 11. 在回溯过程中，如果 node.return 为 null (到达 Fiber 树的根，不应发生在此函数内)
	            //     或者 node.return 等于最初的 wip 父节点，
	            //     说明 wip 的所有子孙节点都已处理完毕，函数可以返回。
	            if (node.return === null || node.return === wip) {
	                return;
	            }
	            // 12. node 指向其父 Fiber 节点，实现向上回溯。
	            node = node?.return;
	        }
	        // 13. 当从内部循环（步骤 10-12）跳出时，说明当前 node 找到了一个兄弟节点。
	        //     确保这个兄弟节点的 return 指针指向正确的父节点 (node.return，即当前回溯到的父节点)。
	        node.sibling.return = node.return;
	        // 14. 将 node 指向其兄弟 Fiber 节点，以便在下一次主循环 (步骤 2) 中处理这个兄弟分支。
	        node = node.sibling;
	    }
	}
	/**
	 * @description 它把所有这些从子孙节点收集到的标记信息，汇总起来，然后统一记录在当前 wip 节点的 subtreeFlags 属性上
	 */
	function bubbleProperties(wip) {
	    let subtreeFlags = NoFlags; // 1. 初始化一个变量，用来累积所有子孙节点的副作用标记
	    let child = wip.child; // 2. 从 wip (当前工作中的父 Fiber 节点) 的第一个子 Fiber 节点开始
	    // 3. 遍历 wip 节点的所有直接子节点
	    while (child !== null) {
	        // 4. 将子节点自身的 subtreeFlags (代表子节点的整个子树中存在的副作用)
	        //    合并到父节点的 subtreeFlags 累积变量中
	        subtreeFlags |= child.subtreeFlags;
	        // 5. 将子节点自身的 flags (代表子节点本身需要执行的副作用)
	        //    也合并到父节点的 subtreeFlags 累积变量中
	        //    因为子节点自身的副作用也是其父节点子树中的一部分需要关注的变更
	        subtreeFlags |= child.flags;
	        // 6. 确保子节点的 return 指针正确地指向 wip (当前父节点)
	        //    这一步主要是为了维护 Fiber 树结构的正确性，
	        //    尽管在其他地方可能已经设置过，但这里可以作为一种保障。
	        child.return = wip;
	        // 7. 移动到下一个兄弟节点，继续循环
	        child = child.sibling;
	    }
	    // 8. 最后，将累积到的所有子孙节点的副作用标记 (subtreeFlags)
	    //    合并到 wip 节点自身的 subtreeFlags 属性上。
	    //    这样，wip.subtreeFlags 就包含了它所有子孙节点中存在的全部副作用标记。
	    wip.subtreeFlags |= subtreeFlags;
	}

	let syncQueue = null;
	let isFlushingSyncQueue = false;
	/**
	 * @description 将一个回调函数添加到一个同步任务队列中
	 */
	function scheduleSyncCallback(callback) {
	    if (syncQueue === null) {
	        syncQueue = [callback];
	    }
	    else {
	        syncQueue.push(callback);
	    }
	}
	/**
	 * @description 执行所有当前在同步任务队列 (syncQueue) 中等待执行的回调函数
	 */
	function flushSyncCallbacks() {
	    if (!isFlushingSyncQueue && syncQueue) {
	        isFlushingSyncQueue = true;
	        try {
	            syncQueue.forEach((callback) => callback());
	        }
	        catch (e) {
	            {
	                console.error('flushSyncCallbacks报错', e);
	            }
	        }
	        finally {
	            isFlushingSyncQueue = false;
	            syncQueue = null;
	        }
	    }
	}

	let workInProgress = null;
	let wipRootRenderLane = NoLane;
	let rootDoesHasPassiveEffects = false;
	/**
	 * @description 为新的渲染或更新周期准备初始环境。
	 *              它会创建一个新的 WIP Fiber 树的根，
	 *              并记录当前更新的优先级。
	 * @param root FiberRootNode，代表整个应用的根。
	 * @param lane 本次更新的优先级。
	 */
	function prepareFreshStack(root, lane) {
	    workInProgress = createWorkInProgress(root.current, {});
	    wipRootRenderLane = lane;
	}
	/**
	 * @description 当一个 Fiber 节点需要更新时，调用此函数来启动更新的调度流程。
	 * @param fiber 触发更新的 Fiber 节点。
	 * @param lane 本次更新的优先级。
	 */
	function scheduleUpdateOnFiber(fiber, lane) {
	    /**
	     * @param root fiberRootNode
	     */
	    const root = markUpdateFromFiberToRoot(fiber);
	    markRootUpdated(root, lane);
	    ensureRootIsScheduled(root);
	}
	// schedule阶段入口
	/**
	 * @description 确保 FiberRootNode 的更新任务被调度执行。
	 *              它会根据待处理更新的最高优先级，决定是同步调度还是异步调度（TODO 部分）。
	 * @param root FiberRootNode，代表整个应用的根。
	 */
	function ensureRootIsScheduled(root) {
	    const updateLane = getHighestPriorityLane(root.pendingLanes);
	    if (updateLane === NoLane) {
	        return;
	    }
	    if (updateLane === SyncLane) {
	        // 同步优先级 用微任务调度
	        {
	            console.log('在微任务中调度，优先级：', updateLane);
	        }
	        // [performSyncWorkOnRoot, performSyncWorkOnRoot, performSyncWorkOnRoot]
	        scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root, updateLane));
	        scheduleMicroTask(flushSyncCallbacks);
	    }
	}
	/**
	 * @description 将一个新的更新优先级 (lane) 合并到 FiberRootNode 的 pendingLanes 中，
	 *              标记这个根节点有新的待处理更新。
	 * @param root FiberRootNode，代表整个应用的根。
	 * @param lane 新的更新优先级。
	 */
	function markRootUpdated(root, lane) {
	    root.pendingLanes = mergeLanes(root.pendingLanes, lane);
	}
	/**
	 * @description 找到这个 Fiber 节点所属的那个唯一的 FiberRootNode
	 * @param fiber
	 * @returns FiberRootNode
	 */
	function markUpdateFromFiberToRoot(fiber) {
	    let node = fiber;
	    let parent = node.return;
	    while (parent !== null) {
	        node = parent;
	        parent = node.return;
	    }
	    if (node.tag === HostRoot) {
	        return node.stateNode;
	    }
	    return null;
	}
	/**
	 * @description 同步更新的入口。
	 * 				它负责初始化渲染环境，
	 *              执行 workLoop 来构建 wip Fiber 树，
	 *              并在完成后调用 commitRoot 来将变更提交到 DOM。
	 * @param root FiberRootNode，代表整个应用的根。
	 * @param lane 当前正在处理的同步优先级 (通常是 SyncLane)。
	 */
	function performSyncWorkOnRoot(root, lane) {
	    const nextLane = getHighestPriorityLane(root.pendingLanes);
	    // 如果当前 root 上挂起的最高优先级不是 SyncLane，则重新调用 ensureRootIsScheduled 来确保正确的调度
	    if (nextLane !== SyncLane) {
	        // 其他比SyncLane低的优先级
	        // NoLane
	        ensureRootIsScheduled(root);
	        return;
	    }
	    {
	        console.warn('render阶段开始');
	    }
	    // 初始化
	    prepareFreshStack(root, lane);
	    do {
	        try {
	            workLoop();
	            break;
	        }
	        catch (e) {
	            {
	                console.warn('workLoop发生错误', e);
	            }
	            workInProgress = null;
	        }
	    } while (true);
	    const finishedWork = root.current.alternate;
	    root.finishedWork = finishedWork;
	    root.finishedLane = lane;
	    // 重置
	    wipRootRenderLane = NoLane;
	    // TODO: commitRoot
	    // wip fiberNode树 树中的flags
	    commitRoot(root);
	}
	/**
	 * @description commit阶段的入口
	 * @param  root FiberRootNode
	 */
	function commitRoot(root) {
	    const finishedWork = root.finishedWork;
	    if (finishedWork === null) {
	        return;
	    }
	    {
	        console.warn('commit阶段开始', finishedWork);
	    }
	    const lane = root.finishedLane;
	    if (lane === NoLane && true) {
	        console.error('commit阶段finishedLane不应该是NoLane');
	    }
	    // 重置
	    root.finishedWork = null;
	    root.finishedLane = NoLane;
	    markRootFinished(root, lane);
	    // 需要执行 useEffect 的回调
	    if ((finishedWork.flags & PassiveMask) !== NoFlags ||
	        (finishedWork.subtreeFlags & PassiveMask) !== NoFlags) {
	        // 防止多次执行 commitRoot 时，执行多次调度
	        if (!rootDoesHasPassiveEffects) {
	            rootDoesHasPassiveEffects = true;
	            // 调度副作用
	            Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, () => {
	                // 执行副作用
	                flushPassiveEffects(root.pendingPassiveEffects);
	                return;
	            });
	        }
	    }
	    // 判断是否存在3个子阶段需要执行的操作
	    // root flags root subtreeFlags
	    const subtreeHasEffect = (finishedWork.subtreeFlags & (MutationMask | PassiveMask)) !== NoFlags;
	    const rootHasEffect = (finishedWork.flags & (MutationMask | PassiveMask)) !== NoFlags;
	    if (subtreeHasEffect || rootHasEffect) {
	        // beforeMutation
	        // mutation Placement
	        commitMutationEffects(finishedWork, root);
	        root.current = finishedWork;
	        // layout
	    }
	    else {
	        root.current = finishedWork;
	    }
	    rootDoesHasPassiveEffects = false;
	    ensureRootIsScheduled(root);
	}
	/**
	 * @description 执行所有待处理的被动副作用 (useEffect 的创建和销毁回调)。
	 * @param pendingPassiveEffects 一个包含 'unmount' 和 'update' 两个 Effect 数组的对象，
	 *                              这些 Effect 是在 commit 阶段收集的。
	 */
	function flushPassiveEffects(pendingPassiveEffects) {
	    // 首先触发所有unmount effect
	    pendingPassiveEffects.unmount.forEach((effect) => {
	        commitHookEffectListUnmount(Passive, effect);
	    });
	    pendingPassiveEffects.unmount = [];
	    // 触发所有上次更新的destroy
	    pendingPassiveEffects.update.forEach((effect) => {
	        commitHookEffectListDestroy(Passive | HookHasEffect, effect);
	    });
	    // 触发所有这次更新的create
	    pendingPassiveEffects.update.forEach((effect) => {
	        commitHookEffectListCreate(Passive | HookHasEffect, effect);
	    });
	    // 回调过程中，触发的更新
	    pendingPassiveEffects.update = [];
	    flushSyncCallbacks();
	}
	/**
	 * @description reconciliation 阶段的核心循环
	 *              它会持续处理 workInProgress 队列中的 Fiber 节点，
	 *              直到整个 work-in-progress Fiber 树构建/更新完毕。
	 */
	function workLoop() {
	    while (workInProgress !== null) {
	        performUnitOfWork(workInProgress);
	    }
	}
	/**
	 * @description 处理单个 Fiber 节点的工作单元。
	 *              它首先执行 "递" 阶段 (beginWork)，然后根据结果
	 *              决定是继续向下处理子节点，还是执行 "归" 阶段 (completeUnitOfWork)。
	 * @param fiber 当前要处理的 work-in-progress Fiber 节点。
	 */
	function performUnitOfWork(fiber) {
	    const next = beginWork(fiber, wipRootRenderLane);
	    fiber.memoizedProps = fiber.pendingProps;
	    if (next === null) {
	        completeUnitOfWork(fiber);
	    }
	    else {
	        workInProgress = next;
	    }
	}
	/**
	 * @description "归"阶段的入口。当一个 Fiber 节点的所有子节点都处理完毕后，
	 *              会调用此函数来完成该节点自身的工作，并确定下一个要处理的节点
	 *              (兄弟节点或父节点)。
	 * @param fiber 当前完成了 "递" 阶段并且没有子节点需要立即处理的 Fiber 节点。
	 */
	function completeUnitOfWork(fiber) {
	    let node = fiber;
	    do {
	        completeWork(node);
	        const sibling = node.sibling;
	        if (sibling !== null) {
	            workInProgress = sibling;
	            return;
	        }
	        node = node.return;
	        workInProgress = node;
	    } while (node !== null);
	}

	/**
	 * @description 创建 React 应用的根容器结构。
	 *              它会创建一个 FiberRootNode (整个应用的根控制器)
	 *              和一个 HostRoot FiberNode (Fiber 树的顶层节点)。
	 * @param container 真实的 DOM 容器元素，React 应用将渲染到这个元素内部。
	 * @returns 返回创建的 FiberRootNode 实例
	 */
	function createContainer(container) {
	    const hostRootFiber = new FiberNode(HostRoot, {}, null);
	    const root = new FiberRootNode(container, hostRootFiber);
	    hostRootFiber.updateQueue = createUpdateQueue();
	    return root;
	}
	/**
	 * @description 触发 React 应用的渲染或更新流程。
	 *              它会创建一个更新对象，将其入队到 HostRoot Fiber 的更新队列中，
	 *              然后调度一次新的渲染工作。
	 * @param element 要渲染的 React 元素 (例如 <App />)，或者 null (表示卸载)。
	 * @param root FiberRootNode 实例，代表整个应用的根。
	 * @returns 返回传入的 element (这主要用于保持 API 的一致性，实际返回值可能不常用)。
	 */
	function updateContainer(element, root) {
	    const hostRootFiber = root.current;
	    const lane = requestUpdateLane();
	    // element: 对应reactDOM.createRoot(root).render(<App />)中的<App />
	    const update = createUpdate(element, lane);
	    enqueueUpdate(hostRootFiber.updateQueue, update);
	    scheduleUpdateOnFiber(hostRootFiber, lane);
	    return element;
	}

	// ReactDOM.createRoot(root).render(<App/>)
	let idCounter = 0;
	function createRoot() {
	    const container = {
	        rootID: idCounter++,
	        children: []
	    };
	    // @ts-ignore
	    const root = createContainer(container);
	    function getChildren(parent) {
	        if (parent) {
	            return parent.children;
	        }
	        return null;
	    }
	    function getChildrenAsJSX(root) {
	        const children = childToJSX(getChildren(root));
	        if (Array.isArray(children)) {
	            return {
	                $$typeof: REACT_ELEMENT_TYPE,
	                type: REACT_FRAGMENT_TYPE,
	                key: null,
	                ref: null,
	                props: { children },
	                __mark: 'KaSong'
	            };
	        }
	        return children;
	    }
	    function childToJSX(child) {
	        if (typeof child === 'string' || typeof child === 'number') {
	            return child;
	        }
	        if (Array.isArray(child)) {
	            if (child.length === 0) {
	                return null;
	            }
	            if (child.length === 1) {
	                return childToJSX(child[0]);
	            }
	            const children = child.map(childToJSX);
	            if (children.every((child) => typeof child === 'string' || typeof child === 'number')) {
	                return children.join('');
	            }
	            // [TextInstance, TextInstance, Instance]
	            return children;
	        }
	        // Instance
	        if (Array.isArray(child.children)) {
	            const instance = child;
	            const children = childToJSX(instance.children);
	            const props = instance.props;
	            if (children !== null) {
	                props.children = children;
	            }
	            return {
	                $$typeof: REACT_ELEMENT_TYPE,
	                type: instance.type,
	                key: null,
	                ref: null,
	                props,
	                __mark: 'Paul'
	            };
	        }
	        // TextInstance
	        return child.text;
	    }
	    return {
	        _Scheduler: Scheduler__namespace,
	        render(element) {
	            return updateContainer(element, root);
	        },
	        getChildren() {
	            return getChildren(container);
	        },
	        getChildrenAsJSX() {
	            return getChildrenAsJSX(container);
	        }
	    };
	}

	var reactNoopRenderer = /*#__PURE__*/Object.freeze({
		__proto__: null,
		createRoot: createRoot
	});

	return reactNoopRenderer;

}));
